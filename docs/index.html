<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Mini Royal Match - Mboka_mj</title>

  <style>
    /* Int√©gration locale de la police Luckiest Guy */
    @font-face {
      font-family: 'Luckiest Guy';
      font-style: normal;
      font-weight: 400;
      src: url('fonts/luckiestguy.ttf') format('truetype');
    }

    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      margin: 0; padding: 0; color: #fff;
      overflow: hidden;
      touch-action: manipulation;
    }
    #game-container {
      background: none;
      width: 100vw;
      height: 100vh;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .header-container {
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      width: 100%;
      padding: 20px 0;
      text-align: center;
      top: 0;
      left: 0;
      border-bottom-left-radius: 20px;
      border-bottom-right-radius: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      z-index: 100; 
    }
    
    .main-title {
      font-family: 'Luckiest Guy', cursive;
      font-size: 60px;
      text-transform: uppercase;
      text-shadow: 4px 4px 8px rgba(0,0,0,0.6);
      color: #fff;
      line-height: 1.1;
      animation: fadein 2s infinite alternate;
    }
    
    .subtitle-text {
        font-family: 'Segoe UI', Tahoma, sans-serif;
        font-size: 24px;
        color: #fff;
        opacity: 0.8;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        margin-top: -10px;
    }
    
    @keyframes fadein {
      from { opacity: 0.4; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1.05); }
    }
    
    @keyframes pulse-shadow {
        0% { transform: scale(1); text-shadow: 4px 4px 8px rgba(0,0,0,0.6); }
        50% { transform: scale(1.05); text-shadow: 6px 6px 12px rgba(0,0,0,0.8); }
        100% { transform: scale(1); text-shadow: 4px 4px 8px rgba(0,0,0,0.6); }
    }
    
    .hud-bar {
      margin-top: 20px; 
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      width: 95%;
      max-width: 900px;
      font-family: 'Luckiest Guy', cursive;
      text-transform: uppercase;
      color: #fff;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    #grid {
      display: grid; 
      gap: 1.5vw;
      justify-content: center; 
      align-content: center;
      margin: 15px auto; 
      padding: 2.5vw;
      background: rgba(255,255,255,0.2); 
      border-radius: 15px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.4);
      max-width: 90vw;
      max-height: 80vh; 
    }
    .cell {
      width: 12vw; 
      height: 12vw; 
      max-width: 80px; 
      max-height: 80px; 
      font-size: 6vw; 
      max-font-size: 48px; 
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px; 
      background: rgba(255,255,255,0.9);
      box-shadow: 0 2px 6px rgba(0,0,0,0.3); 
      cursor: pointer;
      transition: transform 0.15s, background 0.2s;
    }
    .cell.selected { transform: scale(1.15); background: #ffeaa7; border: 2px solid #ffbe76; }
    .cell.hidden-cell { visibility: hidden; }
    .cell.bomb { background: #ff7675; font-size: 32px; }
    .cell.chest { background: #ffd700; }
    .cell.rocket { background: #9b59b6; font-size: 32px; }
    .cell.disco { background: #f1c40f; font-size: 32px; }

    /* NOUVELLES ANIMATIONS */
    @keyframes explode {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.4); opacity: 0.6; }
      100% { transform: scale(0); opacity: 0; }
    }
    .exploding {
      animation: explode 0.3s ease-out forwards;
    }
    
    /* Animation pour l'explosion en cascade */
    @keyframes cascading-explode {
        0% { transform: scale(1); opacity: 1; }
        100% { transform: scale(0); opacity: 0; }
    }

    .cascading-exploding {
        animation: cascading-explode 0.4s ease-out forwards;
    }

    @keyframes bomb-explosion {
      0% { transform: scale(1); background: #ff7675; }
      50% { transform: scale(1.4); background: #f1c40f; }
      100% { transform: scale(0.9); background: #ff7675; }
    }
    .bomb-explosion {
      animation: bomb-explosion 0.4s ease-out;
    }
    
    #buttons { 
      margin-top: 0; 
      margin-bottom: 15px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    button {
      margin: 5px; padding: 15px 30px;
      border: none; border-radius: 8px;
      background: #00cec9; color: white; font-size: 18px;
      cursor: pointer; box-shadow: 0 3px 6px rgba(0,0,0,0.2);
      transition: background 0.2s;
    }
    button:hover { background: #55efc4; }
    #buyLifeBtn, #newBtn, #buyTimeBtn {
        padding: 20px 40px;
        font-size: 20px;
    }
    
    #welcome {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fadein 2s infinite alternate;
      text-align: center;
    }
    #welcome h1 {
        font-size: 40px;
        margin: 20px;
        padding: 0 20px;
        font-family: 'Luckiest Guy', cursive;
    }
    #welcome p {
        font-size: 18px;
    }
    
    /* Styles Royal Match */
    .info-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px 20px;
      border-radius: 25px;
      border: 3px solid #fff;
      background: linear-gradient(180deg, #51a4e2, #25608d);
      box-shadow: 0 5px 10px rgba(0,0,0,0.4);
      min-width: 80px;
      height: 80px;
      margin: 5px;
      flex: 1;
    }
    .info-panel span {
      font-size: 28px;
      margin-top: 5px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    .info-panel div:first-child {
      font-size: 14px;
      opacity: 0.8;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .hud-title {
        font-family: 'Luckiest Guy', cursive;
        text-transform: uppercase;
        font-size: 32px;
        text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        margin: 10px auto;
        color: #fff;
        line-height: 1.2;
    }

    .info-panel.combo { animation: score-vibrate 0.4s ease-in-out; }
    .info-panel.stars-panel span { font-size: 32px; }
    .info-panel.target-panel { position: relative; }
    .target-progress {
        position: absolute;
        bottom: 0; left: 0;
        width: 100%;
        height: 10px;
        background-color: #f39c12;
        border-bottom-left-radius: 22px;
        border-bottom-right-radius: 22px;
        transition: width 0.3s ease-in-out;
    }

    @keyframes score-vibrate {
      0% { transform: scale(1); }
      25% { transform: scale(1.1); }
      50% { transform: scale(0.95); }
      75% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    /* Nouvelles classes pour le pop-up de message */
    #message-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      z-index: 1000;
      font-family: 'Luckiest Guy', cursive;
      color: white;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.6);
      text-align: center;
      padding: 20px;
    }

    #message-popup {
      font-size: 5vw;
      max-font-size: 60px;
      background: rgba(0, 0, 0, 0.5);
      padding: 20px 40px;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 20px rgba(0,0,0,0.4);
      animation: pop-in 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
    }

    #sub-message {
      font-size: 2vw;
      max-font-size: 24px;
      margin-top: 10px;
    }

    @keyframes pop-in {
      0% { transform: scale(0); opacity: 0; }
      80% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
  </style>
</head>
<body>

  <div id="game-container">
    <div id="welcome">
      <h1 class="hud-title">Bienvenue √† Mini Royal Match - Mboka_mj !<br>Appuyez sur le bouton pour d√©marrer l'aventure.</h1>
      <p id="countdown-message"></p>
      <button id="startBtn">Commencer le jeu</button>
    </div>

    <div id="game" style="display:none;">
      <div class="header-container">
          <h1 class="main-title">Mini Royal Match</h1>
          <p class="subtitle-text">Mboka_mj</p>
      </div>
      <div class="hud-bar">
        <div class="info-panel">
          <div>Score</div>
          <span id="score">0</span>
        </div>
        <div class="info-panel lives-panel">
          <div>Vies</div>
          <span id="lives-display"></span>
        </div>
        <div class="info-panel">
          <div>Niveau</div>
          <span id="level">1</span>
        </div>
        <div class="info-panel target-panel">
          <div>Cible</div>
          <span id="target">100</span>
          <div class="target-progress"></div>
        </div>
        <div class="info-panel">
          <div>Temps</div>
          <span id="timer">90</span>
        </div>
        <div class="info-panel stars-panel">
          <div>√âtoiles</div>
          <span id="stars-display"></span>
        </div>
      </div>
      <div id="grid"></div>
      <div id="buttons">
        <button id="buyLifeBtn">Acheter une vie (2‚≠êÔ∏è)</button>
        <button id="buyTimeBtn">Acheter du temps (2‚≠êÔ∏è)</button>
        <button id="newBtn">Nouvelle Partie</button>
        <button id="useBombBtn" style="display:none;">Utiliser une Bombe (<span id="bombCount">0</span>)</button>
      </div>
    </div>
  </div>

  <div id="message-container" style="display:none;">
      <div id="message-popup">
          <div id="main-message"></div>
          <div id="sub-message"></div>
      </div>
  </div>

<script>
  const BASE_TIME = 90;
  const TIME_DECREMENT_PER_LEVEL = 3;
  const TIME_BONUS_FOR_STARS = 15;
  const BASE_TARGET = 100;
  const SCORE_PER_TILE = 2;
  const BOMB_TILES_TO_DESTROY = 4;
  const CHEST_BOMBS_COUNT = 3;
  const CHEST_POINTS = 20;
  const STAR_COST_FOR_LIFE = 2;
  const STAR_COST_FOR_TIME = 2;
  const REGENERATION_TIME = 2 * 60 * 1000;
  const INACTIVITY_TIME_FOR_CHEST = 15;
  const ROCKET_ICON = 'üöÄ';
  const DISCO_ICON = 'üéá';

  const ICON_SETS = [
    ['üçì','üçä','üçã','üçé','üçâ'],
    ['üíé','üî∑','üî∂','üî∫','üîπ'],
    ['üåü','üî•','‚ö°','‚ùÑÔ∏è','‚òòÔ∏è'],
    ['üê±','üê∂','üê∏','üêµ','üêº'],
    ['üåç','üåô','‚òÄÔ∏è','‚ú®','‚≠ê'],
    ['üõ°Ô∏è','‚öîÔ∏è','üëë','üè∞','üèπ'],
    ['üß™','üß´','üß¨','üî¨','ü¶†'],
    ['üéº','üéµ','üé∂','üé∏','ü•Å']
  ];

  const LEVEL_CONFIGS = [
    { name: "Carr√© 8x8", rows: 8, cols: 8, hiddenCells: []},
    { name: "Rectangle 9x7", rows: 9, cols: 7, hiddenCells: []},
    { name: "Triangle", rows: 8, cols: 8, hiddenCells: [
      [0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],
      [1,0],[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[2,0],
      [2,1],[2,2],[2,3],[2,4],[2,5],[3,0],[3,1],[3,2],
      [3,3],[3,4],[4,0],[4,1],[4,2],[4,3],[5,0],[5,1],
      [5,2],[6,0],[6,1],[7,0]
    ]},
    { name: "Croix", rows: 8, cols: 8, hiddenCells: [
      [0,0],[0,1],[0,6],[0,7],
      [1,0],[1,1],[1,6],[1,7],
      [6,0],[6,1],[6,6],[6,7],
      [7,0],[7,1],[7,6],[7,7]
    ]},
    { name: "Sablier", rows: 8, cols: 8, hiddenCells: [
      [0,0],[0,1],[0,6],[0,7],
      [1,0],[1,1],[1,6],[1,7],
      [2,0],[2,1],[2,6],[2,7],
      [5,0],[5,1],[5,6],[5,7],
      [6,0],[6,1],[6,6],[6,7],
      [7,0],[7,1],[7,6],[7,7]
    ]},
    { name: "Trou Central", rows: 8, cols: 8, hiddenCells: [
      [2,2],[2,3],[2,4],[2,5],
      [3,2],[3,3],[3,4],[3,5],
      [4,2],[4,3],[4,4],[4,5],
      [5,2],[5,3],[5,4],[5,5]
    ]}
  ];

  let ROWS, COLS, board=[], selected=null;
  let score=0, level=1, target=BASE_TARGET, timeLeft=BASE_TIME;
  let timerInterval=null, animating=false;
  let bombsInStock = 0;
  let nextChestScore = null;
  let isUsingBomb = false;
  let levelCompleted = false;
  let chestSpawnedThisLevel = false;
  let stars = 0;
  let lives = 3;
  let regenerationInterval = null;
  let levelConfig;
  
  let inactivityTimer = null;
  let inactivityTime = 0;
  let hasMadeValidMove = false;
  
  let messageTimeoutId = null;

  function randInt(n){ return Math.floor(Math.random()*n); }
  function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

  function displayMessage(mainText, subText = "", duration = 2000) {
      clearTimeout(messageTimeoutId);
      const container = document.getElementById('message-container');
      const main = document.getElementById('main-message');
      const sub = document.getElementById('sub-message');

      container.style.display = 'block';
      container.style.transform = 'translate(-50%, -50%) scale(0)';
      main.textContent = mainText;
      sub.textContent = subText;
      
      container.offsetWidth; 
      container.style.transform = 'translate(-50%, -50%) scale(1)';

      messageTimeoutId = setTimeout(() => {
          container.style.display = 'none';
      }, duration);
  }

  function createBoard(){
    board = [];
    for(let r=0;r<ROWS;r++){
      let row=[];
      for(let c=0;c<COLS;c++){
        if(isHidden(r,c)) row.push(null);
        else {
          row.push( randomIcon() );
        }
      }
      board.push(row);
    }
    removeMatchesInit();
  }

  function randomIcon(){
    let icons = ICON_SETS[Math.min(level-1, ICON_SETS.length -1)];
    return icons[randInt(icons.length)];
  }

  function isHidden(r,c){
    return levelConfig.hiddenCells.some(([hr,hc])=>hr===r && hc===c);
  }

  function renderBoard(){
    const grid=document.getElementById("grid");
    grid.innerHTML="";
    
    if (level === 6) {
        grid.style.gap = "1vw";
    } else {
        grid.style.gap = "1.5vw";
    }
    grid.style.gridTemplateColumns=`repeat(${COLS},minmax(0,1fr))`;
    
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell=document.createElement("div");
        cell.className="cell";
        const icon = board[r][c];

        if(icon===null){
          cell.classList.add("hidden-cell");
        } else {
          cell.textContent=icon;
          if(icon==="üéÅ") cell.classList.add("chest");
          else if(icon===ROCKET_ICON) cell.classList.add("rocket");
          else if(icon===DISCO_ICON) cell.classList.add("disco");
          cell.onclick=()=>selectCellWrapper(r,c,cell);
        }
        grid.appendChild(cell);
      }
    }
  }

  async function selectCell(r,c,el){
    if(animating || board[r][c]==null) return;
    
    if(board[r][c] === ROCKET_ICON) {
      await activateRocket(r, c);
      return;
    }
    if(board[r][c] === DISCO_ICON) {
      
    }
    
    if(selected==null){
      selected={r,c,el}; el.classList.add("selected");
    }else{
      if(r===selected.r && c===selected.c){
        selected.el.classList.remove("selected");
        selected=null; return;
      }
      swapAndCheck(selected.r,selected.c,r,c);
      selected.el.classList.remove("selected");
      selected=null;
    }
  }

  async function swapAndCheck(r1,c1,r2,c2){
    if(Math.abs(r1-r2)+Math.abs(c1-c2)!==1) return;

    const firstIsSpecial = board[r1][c1] === ROCKET_ICON || board[r1][c1] === DISCO_ICON;
    const secondIsSpecial = board[r2][c2] === ROCKET_ICON || board[r2][c2] === DISCO_ICON;

    if (firstIsSpecial || secondIsSpecial) {
      if(board[r1][c1] === DISCO_ICON) {
        await activateDisco(r1, c1, board[r2][c2]);
      } else if (board[r2][c2] === DISCO_ICON) {
        await activateDisco(r2, c2, board[r1][c1]);
      } else if (board[r1][c1] === ROCKET_ICON) {
        await activateRocket(r1, c1);
      } else if (board[r2][c2] === ROCKET_ICON) {
        await activateRocket(r2, c2);
      }
      return;
    }
    
    [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
    
    const initialMatches = findMatches();
    if(initialMatches.matches.length===0){
      [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]];
      renderBoard();
      return;
    }
    
    hasMadeValidMove = true;

    renderBoard();
    await handleMatches(initialMatches);
  }

  function findMatches(){
    let matches=[];
    // Matches horizontaux
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
          if (c + 2 < COLS && board[r][c] !== null && board[r][c] === board[r][c+1] && board[r][c] === board[r][c+2]) {
              let startC = c;
              let len = 0;
              while (startC + len < COLS && board[r][c] === board[r][startC+len]) {
                  len++;
              }
              matches.push({r,c,len,dir:"row", type: board[r][c]});
              c += len - 1;
          }
      }
    }
    // Matches verticaux
    for(let c=0;c<COLS;c++){
      for(let r=0;r<ROWS;r++){
          if (r + 2 < ROWS && board[r][c] !== null && board[r][c] === board[r+1][c] && board[r][c] === board[r+2][c]) {
              let startR = r;
              let len = 0;
              while (startR + len < ROWS && board[r][c] === board[startR+len][c]) {
                  len++;
              }
              matches.push({r,c,len,dir:"col", type: board[r][c]});
              r += len - 1;
          }
      }
    }
    return { matches };
  }
  
  async function animateBombEffect(centerR, centerC) {
    const grid = document.getElementById('grid');
    const cellsToAnimate = [];
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = centerR + dr, nc = centerC + dc;
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] !== null && !isHidden(nr, nc)) {
                cellsToAnimate.push(grid.children[nr * COLS + nc]);
            }
        }
    }
    for (let i = 0; i < cellsToAnimate.length; i++) {
        cellsToAnimate[i].classList.add('bomb-explosion');
        await wait(50);
    }
    await wait(400);
    cellsToAnimate.forEach(cell => cell.classList.remove('bomb-explosion'));
  }
  
  async function activateRocket(r, c) {
    animating = true;
    
    const direction = Math.random() < 0.5 ? "row" : "col";
    const cellsToClear = [];
    if (direction === "row") {
        for (let cc = 0; cc < COLS; cc++) {
            if (board[r][cc] !== null && (r !== r || cc !== c)) {
                cellsToClear.push({ r: r, c: cc });
            }
        }
    } else {
        for (let rr = 0; rr < ROWS; rr++) {
            if (board[rr][c] !== null && (rr !== r || c !== c)) {
                cellsToClear.push({ r: rr, c: c });
            }
        }
    }
    
    const rocketCell = document.getElementById('grid').children[r * COLS + c];
    if(rocketCell) rocketCell.classList.add('cascading-exploding');
    board[r][c] = null;
    
    await wait(200);

    for (const cell of cellsToClear) {
      const gridCell = document.getElementById('grid').children[cell.r * COLS + cell.c];
      if (gridCell) {
          gridCell.classList.add('cascading-exploding');
          score += SCORE_PER_TILE;
          updateHUD();
          board[cell.r][cell.c] = null;
          await wait(50);
      }
    }

    updateHUD();
    renderBoard();
    await wait(400);

    applyGravity();
    renderBoard();
    await wait(200);

    await handleMatches();
    animating = false;
  }

  async function activateDisco(r, c, targetIcon) {
    animating = true;
    const cellsToClear = [];
    
    const discoIcon = board[r][c];
    board[r][c] = null;
    
    for (let rr = 0; rr < ROWS; rr++) {
      for (let cc = 0; cc < COLS; cc++) {
        if (board[rr][cc] === targetIcon) {
          cellsToClear.push({ r: rr, c: cc });
        }
      }
    }
    
    const discoCell = document.getElementById('grid').children[r * COLS + c];
    if(discoCell) discoCell.classList.add('cascading-exploding');
    
    await wait(200);

    for (const cell of cellsToClear) {
        const gridCell = document.getElementById('grid').children[cell.r * COLS + cell.c];
        if (gridCell) {
            gridCell.classList.add('cascading-exploding');
            score += SCORE_PER_TILE;
            updateHUD();
            board[cell.r][cell.c] = null;
            await wait(20);
        }
    }

    updateHUD();
    renderBoard();
    await wait(400);

    applyGravity();
    renderBoard();
    await wait(200);
    
    await handleMatches();
    animating = false;
  }
  
  async function handleMatches(initialMatches = null){
    animating = true;
    let { matches } = initialMatches || findMatches();
    
    inactivityTime = 0;

    while(matches.length > 0){
        const scorePanel = document.getElementById("score").parentElement;
        scorePanel.classList.add("combo");

        let cellsToClear = new Set();
        let newSpecialTile = null;

        for(const m of matches){
            if (m.len >= 4 && !newSpecialTile) {
                let specialIcon = m.len >= 5 ? DISCO_ICON : ROCKET_ICON;
                let specialPos = {
                    r: m.r + (m.dir === 'col' ? Math.floor(m.len / 2) : 0),
                    c: m.c + (m.dir === 'row' ? Math.floor(m.len / 2) : 0)
                };
                newSpecialTile = { pos: specialPos, icon: specialIcon };

                for(let i=0; i<m.len; i++){
                    let rr = m.r + (m.dir === "row" ? 0 : i);
                    let cc = m.c + (m.dir === "col" ? 0 : i);
                    if(rr !== specialPos.r || cc !== specialPos.c){
                         if(board[rr][cc] !== "üéÅ") cellsToClear.add(`${rr},${cc}`);
                         score += SCORE_PER_TILE;
                    }
                }
            } else {
                for(let i=0; i<m.len; i++){
                    let rr = m.r + (m.dir === "row" ? 0 : i);
                    let cc = m.c + (m.dir === "col" ? 0 : i);
                    if(board[rr][cc] !== "üéÅ") cellsToClear.add(`${rr},${cc}`);
                    score += SCORE_PER_TILE;
                }
            }
        }
        
        cellsToClear.forEach(coord => {
            const [r, c] = coord.split(',').map(Number);
            const cell = document.getElementById('grid').children[r * COLS + c];
            if (cell) cell.classList.add('exploding');
        });
        
        await wait(300);

        cellsToClear.forEach(coord => {
            const [r, c] = coord.split(',').map(Number);
            board[r][c] = null;
        });
        
        if(newSpecialTile){
            board[newSpecialTile.pos.r][newSpecialTile.pos.c] = newSpecialTile.icon;
        }

        updateHUD();
        renderBoard();
        await wait(200);
        
        scorePanel.classList.remove("combo");
        applyGravity();
        renderBoard();
        await wait(200);
        
        let nextMatches = findMatches();
        matches = nextMatches.matches;
    }

    checkWin();
    animating=false;
  }
  
  async function explodeBomb(r, c) {
    animating = true;
    await animateBombEffect(r, c);

    const cellsToExplode = [];
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] != null && board[nr][nc] !== "üéÅ") {
                cellsToExplode.push({r: nr, c: nc});
            }
        }
    }
    
    for (let i = cellsToExplode.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cellsToExplode[i], cellsToExplode[j]] = [cellsToExplode[j], cellsToExplode[i]];
    }

    for (const cell of cellsToExplode) {
      const gridCell = document.getElementById('grid').children[cell.r * COLS + cell.c];
      if (gridCell) {
          gridCell.classList.add('cascading-exploding');
          score += SCORE_PER_TILE;
          updateHUD();
          board[cell.r][cell.c] = null;
          await wait(75);
      }
    }
  
    applyGravity();
    renderBoard();
    await wait(400);
  
    await handleMatches();
    animating = false;
    checkWin();
  }

  function applyGravity(){
    for(let c=0;c<COLS;c++){
      for(let r=ROWS-1;r>=0;r--){
        if(board[r][c]===null && !isHidden(r,c)){
          for(let rr=r-1;rr>=0;rr--){
            if(board[rr][c]!=null){
              board[r][c]=board[rr][c];
              board[rr][c]=null;
              break;
            }
          }
          if(board[r][c]===null) board[r][c]=randomIcon();
        }
      }
    }
  }

  function removeMatchesInit(){
    let { matches } = findMatches();
    while(matches.length>0){
      for(const match of matches){
        for(let i=0;i<match.len;i++){
          let rr=match.r+(match.dir==="row"?0:i);
          let cc=match.c+(match.dir==="col"?0:i);
          board[rr][cc]=randomIcon();
        }
      }
      ({ matches } = findMatches());
    }
  }

  function startLevel(){
    clearInterval(timerInterval);
    clearInterval(inactivityTimer);
    
    const idx = (level - 1) % LEVEL_CONFIGS.length;
    levelConfig = LEVEL_CONFIGS[idx];
    ROWS = levelConfig.rows;
    COLS = levelConfig.cols;

    score = 0;
    
    timeLeft = Math.max(BASE_TIME - (level - 1) * TIME_DECREMENT_PER_LEVEL, 30);
    target = BASE_TARGET + (level - 1) * 6; 

    isUsingBomb = false;
    levelCompleted = false;
    chestSpawnedThisLevel = false;
    inactivityTime = 0;

    createBoard();
    renderBoard();

    updateHUD();
    
    startTimer();
    startInactivityTimer();
  }
  
  function spawnSpecial(icon){
    let r, c;
    do {
      r = randInt(ROWS);
      c = randInt(COLS);
    } while (board[r][c] === null || board[r][c] === "üéÅ");
    board[r][c] = icon;
    renderBoard();
    
    displayMessage("üéÅ Un coffre est apparu !", "", 2000);
  }
  
  function selectCellWrapper(r,c,el){
    if(animating || board[r][c]===null) return;
    
    if(isUsingBomb){
      explodeBomb(r, c);
      isUsingBomb = false;
      bombsInStock--;
      saveGame();
      updateHUD();
      displayMessage(`üí£ Bombe lanc√©e !`, `+${9 * SCORE_PER_TILE} points`, 1500);
      return;
    }
    
    if(board[r][c]==="üéÅ"){
      bombsInStock += CHEST_BOMBS_COUNT;
      score += CHEST_POINTS;
      saveGame();
      displayMessage(`üéÅ Coffre ouvert !`, `+${CHEST_BOMBS_COUNT} bombes et +${CHEST_POINTS} points`, 1500);

      board[r][c] = null;
      renderBoard();
      applyGravity();
      return;
    }
    
    selectCell(r,c,el);
  }

  function startTimer(){
    clearInterval(timerInterval);
    timerInterval = setInterval(()=>{
      timeLeft--;
      updateHUD();
      if(timeLeft<=0) endGame(false);
    },1000);
  }
  
  function startInactivityTimer(){
    clearInterval(inactivityTimer);
    inactivityTime = 0;
    chestSpawnedThisLevel = false;
    inactivityTimer = setInterval(() => {
        if (!animating && level >= 3 && !chestSpawnedThisLevel) {
            inactivityTime++;
            if (inactivityTime >= INACTIVITY_TIME_FOR_CHEST) {
                spawnSpecial("üéÅ");
                chestSpawnedThisLevel = true;
                clearInterval(inactivityTimer);
            }
        } else {
            inactivityTime = 0;
        }
    }, 1000);
  }

  function endGame(win){
    clearInterval(timerInterval);
    clearInterval(inactivityTimer);

    if(win){
      displayMessage("üéâ Victoire !", `Niveau ${level} termin√© !`, 3000);
      stars++;
      saveGame();
      level++;
      setTimeout(() => {
        startLevel();
      }, 3000);
    } else {
      lives--;
      if(lives > 0){
        displayMessage("‚è≥ Temps √©coul√© !", `Il vous reste ${lives} vies.`, 3000);
        saveGame();
        setTimeout(() => {
            startLevel();
        }, 3000);
      } else {
        displayMessage("‚è≥ Temps √©coul√© !", "Vous n'avez plus de vies. Attendez 2 minutes pour en r√©cup√©rer 3.", 3000);
        saveGame();
        const regenerationTime = Date.now() + REGENERATION_TIME;
        localStorage.setItem('regenerationTime', regenerationTime);
        
        document.getElementById("game").style.display = "none";
        document.getElementById("welcome").style.display = "flex";
        document.getElementById("startBtn").disabled = true;
        startRegenerationCountdown(regenerationTime);
      }
    }
    updateHUD();
  }

  function checkWin(){
    if(score >= target && !levelCompleted) {
      levelCompleted = true;
      endGame(true);
    }
  }

  function saveGame() {
    const gameState = {
      level: level,
      bombsInStock: bombsInStock,
      stars: stars,
      lives: lives
    };
    localStorage.setItem('royalMatchSave', JSON.stringify(gameState));
  }

  function loadGame() {
    const savedState = localStorage.getItem('royalMatchSave');
    if (savedState) {
      const gameState = JSON.parse(savedState);
      level = gameState.level;
      bombsInStock = gameState.bombsInStock || 0;
      stars = gameState.stars || 0;
      lives = gameState.lives || 3;
      return true;
    }
    return false;
  }

  function updateHUD() {
    document.getElementById("score").textContent = score;
    document.getElementById("level").textContent = level;
    document.getElementById("target").textContent = target;
    document.getElementById("timer").textContent = timeLeft;
    
    const progress = Math.min(100, (score / target) * 100);
    document.querySelector('.target-progress').style.width = `${progress}%`;
    
    document.getElementById("bombCount").textContent = bombsInStock;
    
    const livesDisplay = document.getElementById("lives-display");
    livesDisplay.textContent = "‚ù§Ô∏è".repeat(lives);

    const starsDisplay = document.getElementById("stars-display");
    starsDisplay.textContent = "‚≠êÔ∏è x" + stars;
    
    document.getElementById("buyLifeBtn").disabled = stars < STAR_COST_FOR_LIFE;
    document.getElementById("buyTimeBtn").disabled = stars < STAR_COST_FOR_TIME;
    document.getElementById("useBombBtn").style.display = bombsInStock > 0 ? 'inline-block' : 'none';
  }

  function startRegenerationCountdown(regenerationTime) {
      clearInterval(regenerationInterval);
      regenerationInterval = setInterval(() => {
          const timeLeft = Math.floor((regenerationTime - Date.now()) / 1000);
          if (timeLeft <= 0) {
              clearInterval(regenerationInterval);
              localStorage.removeItem('regenerationTime');
              lives = 3;
              document.getElementById("countdown-message").textContent = "Vos vies sont r√©g√©n√©r√©es !";
              document.getElementById("startBtn").disabled = false;
              saveGame();
              updateHUD();
          } else {
              const minutes = Math.floor(timeLeft / 60);
              const seconds = timeLeft % 60;
              document.getElementById("countdown-message").textContent = `Vies √©puis√©es. R√©g√©n√©ration dans ${minutes}m ${seconds}s`;
          }
      }, 1000);
  }

  document.getElementById("startBtn").onclick=()=>{
    const regenerationTime = localStorage.getItem('regenerationTime');
    if (regenerationTime && Date.now() < regenerationTime) {
        startRegenerationCountdown(regenerationTime);
        document.getElementById("startBtn").disabled = true;
        return;
    }

    document.getElementById("welcome").style.display="none";
    document.getElementById("game").style.display="block";
    if (loadGame()) {
      displayMessage("Partie charg√©e !", "Reprenez l√† o√π vous vous √©tiez arr√™t√©.", 2000);
    }
    updateHUD();
    startLevel();
  };

  document.getElementById("newBtn").onclick=()=>{
    score=0;
    level=1;
    bombsInStock=0;
    stars=0;
    lives=3;
    localStorage.removeItem('royalMatchSave');
    localStorage.removeItem('regenerationTime');
    updateHUD();
    startLevel();
  };
  
  document.getElementById("useBombBtn").onclick = () => {
    if(bombsInStock > 0){
      isUsingBomb = true;
      displayMessage("Cliquez sur une tuile", "pour utiliser une bombe !", 2000);
    }
  };

  document.getElementById("buyLifeBtn").onclick = () => {
      if (stars >= STAR_COST_FOR_LIFE) {
          stars -= STAR_COST_FOR_LIFE;
          lives++;
          displayMessage("Vie achet√©e !", `Il vous reste ${lives} vies.`, 2000);
          updateHUD();
          saveGame();
      } else {
          displayMessage("Pas assez d'√©toiles !", "Il vous faut 2 √©toiles pour une vie.", 2000);
      }
  };

  document.getElementById("buyTimeBtn").onclick = () => {
      if (stars >= STAR_COST_FOR_TIME) {
          stars -= STAR_COST_FOR_TIME;
          timeLeft += TIME_BONUS_FOR_STARS;
          displayMessage("Temps achet√© !", `+${TIME_BONUS_FOR_STARS} secondes`, 2000);
          updateHUD();
          saveGame();
      } else {
          displayMessage("Pas assez d'√©toiles !", "Il vous faut 2 √©toiles pour du temps.", 2000);
      }
  };
</script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('sw.js').then(function(registration) {
        console.log('Service Worker enregistr√© avec succ√®s:', registration.scope);
      }, function(err) {
        console.log('Erreur d‚Äôenregistrement du Service Worker:', err);
      });
    });
  }
</script>
</body>
</html>
